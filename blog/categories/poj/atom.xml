<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: poj | iceout's blog]]></title>
  <link href="http://iceout.github.com/blog/categories/poj/atom.xml" rel="self"/>
  <link href="http://iceout.github.com/"/>
  <updated>2013-03-25T21:12:55+08:00</updated>
  <id>http://iceout.github.com/</id>
  <author>
    <name><![CDATA[iceout]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[poj 1035:Spell checker]]></title>
    <link href="http://iceout.github.com/blog/2012/05/07/poj-1035/"/>
    <updated>2012-05-07T12:36:00+08:00</updated>
    <id>http://iceout.github.com/blog/2012/05/07/poj-1035</id>
    <content type="html"><![CDATA[<h2 id="section">题目说明</h2>
<p><a href="http://poj.org/problem?id=1035">原题在这里。</a></p>

<p>很简单的一道题，输入分为两部分，首先是一个字典,最多包含10000个词语。以一个“#”作为字典的结束。
剩余部分为需要检查的词语，也是以“#”结束。</p>

<p>所有的词语都是由小写字母组成，最多包含15个字母。每个词占语一行。
如果所检查的词语正确则输出“is correct”，否则则根据三条规则输出相近的词语。三条规则如下：</p>

<ul>
  <li>leting of one letter from the word;</li>
  <li>replacing of one letter in the word with an arbitrary letter;</li>
  <li>inserting of one arbitrary letter into the word. </li>
</ul>

<!--more-->

<h2 id="section-1">程序代码</h2>
<p>我的初步解法内存消耗360K，时间235MS。代码在<a href="https://github.com/iceout/poj/blob/a76987067dc373785e245cf990e8258ea21c2984/poj1035.c">这里</a>，其实结构还算清晰，就是效率不高，-_-，待优化。</p>

<p><em>update：</em>
进行了一些优化，首先进行排序，然后通过二分法查找是否为正确的词语，是的话输出，否则就查找相近的词语。
内存增加到了440K，时间缩短为125MS。不知道那些60、70MS怎么优化的。。。</p>

<p>```c++ poj1035:spell checker https://github.com/iceout/poj/blob/master/poj1035.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h /></string.h></stdio.h></p>

<p>char dic[10000][16];
int sorted[10000][2];</p>

<p>int check(char *s, char *b, int small);</p>

<p>int ncom(const void * p, const void * q)
{
    return *(int *)p - *(int *)q;
}</p>

<p>int comp(const void * p, const void * q)
{
    if (((int *)p)[1] &lt; ((int *)q)[1]) {
        return -1;
    }
    else if (((int *)p)[1] == ((int *)q)[1]) {
        return strcmp(dic[((int *)p)[0]], dic[((int *)q)[0]]);
    }
    else {
        return 1;
    }
}</p>

<p>int main(int argc, char * const argv[])
{
    int i, j;
    int numdic = 0;</p>

<pre><code>char word[16];
int lenword = 0;
int replace[10000];
int t;
int count;
int first, mid, last;

/*Read the dict*/
while (1 == 1) {
    scanf("%s", dic[numdic]);
    if (dic[numdic][0] == '#') {
        break;
    }
    replace[numdic] = 0;
    sorted[numdic][0] = numdic;
    sorted[numdic][1] = strlen(dic[numdic]);
    numdic++;
}

qsort(sorted, numdic, sizeof(int)*2, comp);

while (1 == 1) {
    scanf("%s", word);
    if (word[0] == '#') {
        break;
    }
    printf("%s", word);
    lenword = strlen(word);
    i = -1;
    while (++i &lt; numdic &amp;&amp; sorted[i][1] &lt; lenword);

    if (i &lt; numdic) {
        first = i;
        i--;
        while (++i &lt; numdic &amp;&amp; sorted[i][1] == lenword);
        last = i-1;
        mid = (last - first)/2;
        j = -1;
        while (1 == 1) {
            if (last &lt; first) {
                break;
            }
            mid = first + (last - first)/2;
            j = strcmp(dic[sorted[mid][0]], word);
            if (j == 0) {
                printf(" is correct\n");
                break;
            }
            else if (j &lt; 0) {
                first = mid+1;
            }
            else {
                last = mid-1;
            }
        }
        if (j == 0) {
            continue;
        }
    }
    count = -1;
    i = -1;
    t = 0;
    while (++i &lt; numdic &amp;&amp; sorted[i][1] &lt; lenword-1);
    while (i &lt; numdic) {
        if (lenword-1 == sorted[i][1]) {
            if (check(dic[sorted[i][0]], word, lenword-1) == 1) {
                replace[t++] = sorted[i][0];
            }
        }
        else if (lenword == sorted[i][1]) {
            count = 0;
            for (j = 0; j &lt; lenword; j++) {
                if (word[j] != dic[sorted[i][0]][j]) {
                    count++;
                }
            }
            if (count == 1){
                replace[t++] = sorted[i][0];
            }
        }
        else if (lenword+1 == sorted[i][1]) {
            if (check(word, dic[sorted[i][0]], lenword) == 1) {
                replace[t++] = sorted[i][0];
            }
        }
        else {
            break;
        }
        i++;
    }
    if (count != 0) {
        qsort(replace, t, sizeof(int), ncom);
        printf(":");
        j = 0;
        while (j &lt; t) {
            printf(" %s", dic[replace[j++]]);
        }
        printf("\n");
    }
}
return 0; }
</code></pre>

<p>int check(char *s, char *b, int small)
{
    int i = 0, j = 0;</p>

<pre><code>while (s[i] == b[j]) {
    i++;
    j++;
    if (i &gt;= small) {
        return 1;
    }
}
j++;
while (s[i] == b[j]) {
    i++;
    j++;
    if (i &gt;= small) {
        return 1;
    }
}

return 0; } ```
</code></pre>
]]></content>
  </entry>
  
</feed>
